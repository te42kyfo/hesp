#!/usr/bin/guile \
-e main -s
!#

(use-modules (ice-9 pretty-print)
             (ice-9 format)
             (ice-9 rdelim)
             (ice-9 iconv)
             (ice-9 binary-ports)
             (ice-9 receive)
             (rnrs bytevectors)
             (system foreign))

(load-extension
 (string-concatenate
  (list (getcwd) "/guile-opencl/lib/libguile-opencl.so")) "init_guile_opencl")

; output with exactly the formatting of the reference output
(define (hesp-print obj)
  (let ((fmt (if (cl-platform? obj) "~22a = ~a~%" "~39a = ~a~%")))
    (map (lambda (x)
           (format #t fmt (car x) (cdr x)))
         (cl-info obj))))

(define (hesp-select list name)
  (let* ((len (length list))
         (selection
          (if (= 1 len)
              (car list)
              (begin
                (format #t "Avilable ~as:~%" name)
                (for-each (lambda (item id)
                            (format #t "~:@(~a~) #~d:~%" name id)
                            (hesp-print item) (newline))
                          list (iota len))
                (format #t "Choose a ~a (from 0 to ~d)~%" name (1- len))
                (list-ref list (string->number (read-line)))))))
    (format #t "Using the following ~a:~%" name)
    (hesp-print selection)
    (newline)
    selection))

(define force-src "
#define real float

__kernel void force( const unsigned int N, global real * m,
			  	     global real * px, global real * py, global real * pz,
				     global real * fx, global real * fy, global real * fz ) {

    const int globalid = get_global_id(0);
    fx[globalid] = px[globalid]*2;
}")



(define (main args)
  (let* ((platform (hesp-select (get-cl-platforms) "platform"))
         (device   (hesp-select (get-cl-devices platform) "device"))
         (context  (make-cl-context device))
         (queue    (make-cl-queue context device))
         (program  (build-cl-program
                    (string->cl-program context force-src)
                    (list device)
                    "-cl-fast-relaxed-math"))
         (force-kernel (make-cl-kernel program "force")))

    (let* ((N     10)
           (px     (make-f32vector N 0.0))
		   (py     (make-f32vector N 0.0))
		   (pz     (make-f32vector N 0.0))
		   (m      (make-f32vector N 1.0))
		   (fx     (make-f32vector N 0.0))
		   (fy     (make-f32vector N 0.0))
		   (fz     (make-f32vector N 0.0))

           (px-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (py-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (pz-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (m-dev  (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (fx-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (fy-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float))))
		   (fz-dev (make-cl-buffer context CL_MEM_READ_WRITE
								   (* N (sizeof float)))) )

	  (do ((i 0 (1+ i)))
		  (( >= i N ))
		(bytevector-ieee-single-native-set! px (* i (sizeof float)) (/ i N)) )

;	  (bytevector-ieee-single-native-set! px (* 5 4) 1000.0)

      (enqueue-write-cl-buffer queue px-dev 0 px)
      (enqueue-write-cl-buffer queue py-dev 0 py)
      (enqueue-write-cl-buffer queue pz-dev 0 pz)
	  (enqueue-write-cl-buffer queue m-dev 0 m)
	  (enqueue-write-cl-buffer queue fx-dev 0 fx)
      (enqueue-write-cl-buffer queue fy-dev 0 fy)
      (enqueue-write-cl-buffer queue fz-dev 0 fz)

      (cl-finish queue)
      (set-cl-kernel-arg force-kernel 0 (make-u32vector 1 N) )
      (set-cl-kernel-arg force-kernel 1 m-dev)
      (set-cl-kernel-arg force-kernel 2 px-dev)
      (set-cl-kernel-arg force-kernel 3 py-dev)
      (set-cl-kernel-arg force-kernel 4 pz-dev)
      (set-cl-kernel-arg force-kernel 5 fx-dev)
      (set-cl-kernel-arg force-kernel 6 fx-dev)
      (set-cl-kernel-arg force-kernel 7 fz-dev)


      (enqueue-cl-kernel queue force-kernel
                         (list 0)
                         (list N)
                         (list 10))
      (enqueue-read-cl-buffer queue fx-dev 0 fx)
      (cl-finish queue)

    (format #t "~a\n" fx)
	(format #t "~a\n" px)
	(format #t "all good!\n"))))
